# 항상 객체 지향 프로그래밍을 사용하십시오 #

> 객체 지향 언어의 문제점은 묵시적인 환경을 가지고 있다는 것입니다. 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라였습니다.
>
>-Joe Armstrong - [작업중인 코더-프로그래밍 기술에 대한 고찰](http://codersatwork.com/)


> 추상화는 강력합니다. 제가 90 년대에 실제로 알레르기 반응을 보인 것은 CORBA, COM, DCOM, 객체 지향 넌센스였습니다. 모든 스타트업에는 "Hello world" 를 출력하기 위해 200,000개의 메소드 호출을 하는 미친 일도 있었습니다. 그것은 비극입니다! 당신은 그런 종류의 일과 관련된 프로그래머가되고 싶지 않을 것입니다.
>
>-브렌든 아이크 (Brendan Eich) - [직장 코더-프로그래밍 기술에 대한 고찰](http://codersatwork.com/)

오늘날 많은 소프트웨어 개발자와 많은 회사에서 객체 지향 프로그래밍이 소프트웨어를 개발할 수 있는 유일한 방법이라고 생각합니다. 객체 지향 프로그래밍에 반대하는 사람은 즉시 업계의 "전통적인 지혜"에 대해 논쟁하고 있다는 사실을 의식하게 됩니다.

프로그래밍 블로그와 포럼에는 대단한 많은 사람들이 객체 지향에 대해 정의하고, 알고 있는것과 느끼고 있는 것에 대해 논의하고 확신하는 사람들이 많습니다. 객체지향에 표준 정의는 없다는 사실을 간과한 채로요.

사실 객체 지향 프로그래밍이라 불리는 것은 종종 불필요한 복잡성으로 인한 무거운 부담을 만들어 냅니다.

컴퓨터 과학자와 프로그래머로서 우리는 편견을 없애고 주어진 문제에 대한 최상의 해결책을 찾는 법을 배워야합니다.

오늘날 PHP의 주요 장점 중 하나는 명령형, 기능성, 객체 지향, 절차 및 반사 패러다임에 대한 지원입니다. PHP는 여러 가지 도구를 갖춘 거대한 도구 상자로, **한가지 방법 만이 아니라** 여러 가지 방법으로 많은 문제를 해결할 수 있습니다.

**응용 프로그램 내에서 서로 다른 문제를 하나의 특정 프로그래밍 패러다임에 강제로 끼워맞춘다면 우리는 창의적으로 생각할 수 없고, 효과적으로 일할 수 없습니다.!**

## 작은 역사 수업 ##

특정 프로그래밍 패러다임을 이해하는 가장 좋은 방법 중 하나는 그것이 어떻게 진화했는지를 보는 것입니다. 개발 이유는 무엇입니까? 새로운 사고 방식이 필요한 다른 프로그래밍 패러다임에는 어떤 문제가 있습니까? 실제 문제입니까 아니면 단순히 학문 문제입니까? 그리고 어떻게 진화 했습니까?

X의 말이나 Y의 정의에 상관없이 패러다임의 맥락에서 중요한 것은 그것들을 만든 역사입니다.

소프트웨어 설계는 두 가지 방법으로 구성 할 수 있습니다. 한 가지 방법은 간단하게 결함이 없도록하는 것입니다. 그리고 다른 방법은 명백한 결함이 없도록 너무 복잡하게 만드는 것입니다.

>
>-[C.A.R. Hoare](https://en.wikiquote.org/wiki/C._A._R._Hoare)


예전에, 50 년대 말에 객체 지향 프로그래밍이 출현하기 전, 많은 소프트웨어가 구조화되지 않은 프로그래밍을 강조하는 프로그래밍 언어 (때로는 1세대 및 2세대 언어라고 함)를 사용하여 개발되었습니다. 비구조적 프로그래밍은 역사적으로 가장 초기의 프로그래밍 패러다임입니다. 비구조적 프로그래밍은  "스파게티"코드를 제작 한 것에 대해 비판을 받았었습니다.

비구조적 프로그래밍을 사용하는 고급 및 저수준 프로그래밍 언어가 있습니다. 여기에는 BASIC의 초기 버전, COBOL, MUMPS, JOSS, FOCAL, TELCOMP, 기계어, 초기 어셈블러 시스템 (절차적 메타 연산자가 없는 시스템) 및 일부 스크립팅 언어가 포함됩니다.

구조화되지 않은 언어로 작성된 프로그램은 일반적으로 순차적으로 정렬 된 명령 또는 명령문이 일반적으로 각 행(줄) 에 하나씩 있는 형태로 구성됩니다. 행은 보통 번호가 매겨져 있거나 레이블이 있거나 둘 다 있습니다. 이 레이블을 사용하면 실행 흐름이 (goto 문 등을 이용해서) 프로그램의 모든 행으로 이동할 수 있습니다.

그런 다음 60년대에 Edsger W. Dijkstra의 유명한 서한으로 인해 구조화 된 프로그래밍이 등장했습니다. [Go To statements considered harmful](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html).

구조적 프로그래밍은 서브 루틴, 블록 구조 및 루프를 사용하여 소프트웨어의 명확성, 품질 및 개발을 향상시키는 프로그래밍 패러다임입니다. 이것은 GOTO 문과 같은 간단한 점프를 사용하는 것과 대조적입니다.

이후 구조적 프로그래밍에서 절차적 프로그래밍이 파생되었습니다. 절차적 프로그래밍은 "프로시저 호출"이라는 개념을 기반으로 합니다. "프로시저 호출"은 "함수 호출"의 또다른 이름입니다. 절차는 루틴, 서브 루틴 또는 메소드라고도 합니다. 프로시저는 단순히 실행할 일련의 연산을 순서대로 가지고 있습니다. 프로시저는 자신을 포함해서 어떤 프로시져도 호출할 수 있습니다.

처음에는 모든 프로시저들은 프로그램의 어느 부분에서나 전역 데이터를 사용할 수 있었습니다. 작은 프로그램에서는 이것이 문제가 되지 않았지만, 업무가 복잡해지고 프로그램의 크기가 커짐에 따라 프로그램의 한 부분에 대한 작은 변경은 다른 많은 부분에 큰 영향을 미쳤습니다.

프로그램의 변경을 위해서는 많은 의존성을 확인해야 하는 것을 누구의 계획에도 없었던 일입니다. 하나의 프로시저에서 사소한 변경이 일어나면 원본 코드에 의존하는 수많은 프로시저에서 연쇄적으로 오류가 발생합니다.

데이터를 "개체"라고 하는 분리된 범위로 나눌 수있는 새로운 기술이 발전했습니다. 같은 범위에 속하는 특정 프로시저만 동일한 데이터에 액세스 할 수 있습니다. 이를 캡슐화라고 합니다. 결과는 훨씬 더 체계적인 코드였습니다.

처음에는 객체를 객체라고 부르지 않았으며, 단지 별도의 범위로 간주되었습니다. 나중에 의존성이 줄어들고 이러한 범위 내의 프로 시저와 변수 간의 연결이 분리된 영역으로 간주되고 나서 "객체"및 "객체 지향 프로그래밍"의 개념을 탄생했습니다.

이후 자바(Java) 의 개발로 인해 "프로시저"나 "함수"는 더이상 "함수" 라고 부르지 않고 자바의 "buzzwords" 인 "메소드" 로 이름이 변경되었습니다. 변수 또한 더이상 "변수" 라고 부르지 않고 "속성(attribute 혹은 property)" 라고 이름이 바뀌었습니다. "메소드"와 "속성" 은 둘 다 "분리된 영역" 안에 있을 때 부르는 이름입니다.

따라서 객체는 본질적으로 단순히 "분리된 영역 안에 있는 메소드 및 속성" 이라고 하는 함수 및 변수의 모음입니다.

메소드와 속성이 별도의 범위 내에서 격리되는 방법은 "클래스"를 사용하는 것입니다. 일단 인스턴스화되면 클래스를 객체라고 합니다.

객체는 서로를 참조 할 수 있으며 이러한 참조를 통해 내부의 메소드 (함수)는 서로 "통신"할 수 있습니다. 객체는 다른 객체로부터 메소드를 "상속"하여 확장 할 수 있으며 이를 "상속"이라고합니다. 코드를 재사용하고 공개 클래스와 인터페이스를 통해 소프트웨어의 독립적인 확장을 가능하게 하는 방법입니다. 객체의 관계는 계층 구조를 만듭니다. 상속은 프로그래밍 언어 [Simula 67](http://en.wikipedia.org/wiki/Simula)에 대해 1967 년에 발명되었습니다.

객체는 다른 객체의 메소드를 상속하고 추가되거나 변경된 기능을 "재정의"할 수 있는데 이를 "다형성"이라고 합니다.

이러한 다양한 아이디어가 구현되는 방식은 프로그래밍 언어마다 다릅니다.

객체 지향 프로그래밍은 이전과 다른 방식으로 코드를 구성하는 것입니다. 프로시저 프로그래밍의 확장이며 데이터를 숨기고 (캡슐화) 전역 범위를 피하는 것입니다. 실제로 원래 코드(상속)에 영향을 주지 않고 원본 객체의 청사진(blueprint)을 "빌려" 기능을 확장하는 것입니다. 그리고 원래 코드 (다형성)에 영향을 미치지 않고 함수를 재정의하는 것입니다.

> 객체 지향 모델을 사용하면 프로그램을 쉽게 구성 할 수 있습니다. 실제로 이것이 의미하는 바는 스파게티 코드를 작성하는 구조화 된 방법을 제공한다는 것입니다.
>
>-Paul Graham : [Ansi Common Lisp](https://openlibrary.org/works/OL7944696W/ANSI_Common_Lisp)

** 잘못된 방법 ** : 항상 객체 지향 프로그래밍을 사용하십시오. ![thumbs down](https://phpthewrongway.com/img/thumbs-down.png)